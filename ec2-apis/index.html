<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Scheduling tasks in the cloud with EC2 APIs &#8211; Spencer Boucher</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="Spencer Boucher">
    <meta name="keywords" content="">
    <link rel="canonical" href="http://spencerboucher.com/ec2-apis/">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for Spencer Boucher" href="/feed.xml" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?201601181942" type="text/css">

    <!-- Fonts -->
    <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
    

    <!-- MathJax -->
    
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    

    <!-- Verifications -->
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Scheduling tasks in the cloud with EC2 APIs">
    <meta property="og:description" content="">
    <meta property="og:url" content="http://spencerboucher.com/ec2-apis/">
    <meta property="og:site_name" content="Spencer Boucher">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    
        <meta name="twitter:site" content="@justmytwospence" />
    
    <meta name="twitter:title" content="Scheduling tasks in the cloud with EC2 APIs" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:url" content="http://spencerboucher.com/ec2-apis/" />

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">

    
    <script type="text/javascript">
       (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
       (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
       m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
       })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
       ga('create', 'UA-45101202-1', 'auto');
       ga('send', 'pageview');
    </script>
    
</head>

<body class="site animated fade-in-down">

	

  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="http://spencerboucher.com" class="site-title">Spencer Boucher</a>
      <nav class="site-nav">
        
    

    
        <a href="/about/">About</a>
    

    

    

    

    

    

    

    

    

    


    

    

    
        <a href="/contact/">Contact</a>
    

    

    

    

    

    

    

    

    


      </nav>
      <div class="clearfix"></div>
      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>Scheduling tasks in the cloud with EC2 APIs</h1>
  <span class="post-meta">January 12, 2014</span><br>
  
  <span class="post-meta small">
  
    9 minute read
  
  </span>
</div>

<article class="post-content">
  <p>This post is sort of an addendum to our <a href="">live-mapping project</a>, but
it should also be of use to anyone looking to run an arbitrary script
on a recurring schedule. Originally, we set up a 24/7 instance on
<a href="http://aws.amazon.com/ec2">Amazon&rsquo;s Elastic Compute Cloud</a> that ran a
daily <code>cron</code> job. This works, but its a bit wasteful because we&rsquo;re
paying for 24 hours of cloud even though we&rsquo;re only actually using it
for maybe 5 minutes a day.</p>

<p>Fortunately, Amazon provides a
<a href="http://aws.amazon.com/developertools">schmorgesborg</a> of command line
interface (CLI) tools that allow us to manage our cloud instances more
efficiently. Specifically, we want to schedule an instance to spin up
only once a day, execute our script, then shut back down. To
accomplish this, we will want three CLI tools:
<a href="http://aws.amazon.com/developertools/368">the Amazon EC2 AMI Tools</a> ,
<a href="http://aws.amazon.com/developertools/351">the Amazon EC2 API Tools</a>
,and
<a href="http://aws.amazon.com/developertools/2535">the Auto Scaling Command Line Tool</a>
. If you&rsquo;re on a Mac, it&rsquo;s way easier to get these with
<a href="http://brew.sh">Homebrew</a> than by downloading from Amazon&rsquo;s website:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">brew install ec2-ami-tools <span class="c"># For creating an AMI from an existing machine</span>
brew install ec2-api-tools <span class="c"># For registering and launching instances</span>
brew install aws-as <span class="c"># For creating auto scaling groups/defining schedules</span>
</code></pre></div>
<p>As an extra Homebrew bonus, running <code>brew info ec2-ami-tools</code>, <code>brew
info ec2-api-tools</code>, and <code>brew info aws-as</code> will now tell us exactly
what we need to do to get our authentication and environment variables
all set up. First we are told to download the necessary .pem files
from the Amazon console and place them into a new hidden directory of
our home directory <code>.ec2</code>. Then we tell our command line where
everything lives now by inserting the following lines into our
<code>.bashrc</code>:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">export </span><span class="nv">EC2_PRIVATE_KEY</span><span class="o">=</span><span class="s2">"</span><span class="k">$(</span>/bin/ls <span class="s2">"</span><span class="nv">$HOME</span><span class="s2">"</span>/.ec2/pk-<span class="k">*</span>.pem | /usr/bin/head -1<span class="k">)</span><span class="s2">"</span>
<span class="nb">export </span><span class="nv">EC2_CERT</span><span class="o">=</span><span class="s2">"</span><span class="k">$(</span>/bin/ls <span class="s2">"</span><span class="nv">$HOME</span><span class="s2">"</span>/.ec2/cert-<span class="k">*</span>.pem | /usr/bin/head -1<span class="k">)</span><span class="s2">"</span>
<span class="nb">export </span><span class="nv">EC2_HOME</span><span class="o">=</span><span class="s2">"/usr/local/Cellar/ec2-api-tools/1.6.12.0/libexec"</span>
<span class="nb">export </span><span class="nv">AWS_AUTO_SCALING_HOME</span><span class="o">=</span><span class="s2">"/usr/local/Cellar/auto-scaling/1.0.61.4/libexec"</span>
<span class="nb">export </span><span class="nv">EC2_AMITOOL_HOME</span><span class="o">=</span><span class="s2">"/usr/local/Cellar/ec2-ami-tools/1.4.0.9/libexec"</span>
<span class="nb">export </span><span class="nv">EC2_REGION</span><span class="o">=</span><span class="s2">"us-west-2"</span>
<span class="nb">export </span><span class="nv">EC2_ZONE</span><span class="o">=</span><span class="k">${</span><span class="nv">EC2_REGION</span><span class="k">}</span>a
<span class="nb">export </span><span class="nv">EC2_URL</span><span class="o">=</span>https://<span class="nv">$EC2_REGION</span>.ec2.amazonaws.com
<span class="nb">export </span><span class="nv">AWS_AUTO_SCALING_URL</span><span class="o">=</span>https://autoscaling.<span class="nv">$EC2_REGION</span>.amazonaws.com
</code></pre></div>
<p>Its pretty simple, but if you have any trouble with this part, refer
to the official
<a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/SettingUp_CommandLine.html">Amazon documentation for setting up the command line</a>.</p>

<p>Because these environment variables are recognized out of the box by
the CLI tools, we won&rsquo;t need to point to our authentication keys or
specify a region every time we make an API call and our next commands
will be much more succinct. Note that every EC2 instance is physically
located at one of several regions; we are using us-west-2 because it
happens to be where I spun up the existing instance that currently
holds our &ldquo;update.py&rdquo; script, but any of them would probably work just
fine for the simple job at hand.</p>

<div class="table-responsive"> <table class="table table-striped
  table-condensed "> <tr> <th>Code</th> <th>Region</th> </tr> <tr>
  <td>ap-northeast-1</td> <td> Asia Pacific (Tokyo) Region</td> </tr>
  <tr> <td>ap-southeast-1</td> <td>Asia Pacific (Singapore)
  Region</td> </tr> <tr> <td>ap-southeast-2</td> <td>Asia Pacific
  (Sydney) Region</td> </tr> <tr> <td>eu-west-1</td> <td>EU (Ireland)
  Region</td> </tr> <tr> <td>sa-east-1</td> <td>South America (Sao
  Paulo) Region</td> </tr> <tr> <td>us-east-1</td> <td>US East
  (Northern Virginia) Region</td> </tr> <tr> <td>us-west-1</td> <td>US
  West (Northern California) Region</td> </tr> <tr> <td>us-west-2</td>
  <td>US West (Oregon) Region</td> </tr> </table> </div>

<p>So, first things first. We can&rsquo;t just spin up an off-the-rack EC2
instance every day, because we&rsquo;ll run into the same problem that I
originally had with my web host: the Python modules that we need won&rsquo;t
be installed. We <em>could</em> write a script that would install <code>pip</code> plus
all of the requisite Python modules and run it first thing after we
launch the instance, but there&rsquo;s a better way:</p>

<p><code>bash ec2-create-image i-8918e1be -n &quot;Map Update Image&quot;</code></p>

<p>This command from <code>ec2-ami-tools</code> creates an &ldquo;Amazon Machine Image&rdquo; of
the instance that we previously had running and names it &ldquo;Map Update
Image&rdquo;. A new image ID will now print to your console, <code>ami-fcdfb9cc</code>
in my case. This is tantamount to cloning the instance, because we can
now reference the new image ID when we spin up new instances and all
of our modules, scripts, etc. will be there waiting for us. Note that
I removed the instance&rsquo;s <code>cron</code> job <em>before</em> creating the AMI, because
we&rsquo;ll now be handling the task scheduling from <em>outside</em> the instance,
via <strong>autoscaling</strong>.</p>

<p>Next let&rsquo;s write a shell script that will execute our Python
map-updating script, shoot us a diagnostic email, then shut down the
instance that its running on. The idea here is that once a day we&rsquo;re
going to spin up an instance using our shiny new AMI and immediately
run this new script (let&rsquo;s call it &ldquo;update.sh&rdquo;) that will do its
business and then promptly commit seppuku and stop charging us
money. Eric Hammond has created a great template on
<a href="http://alestic.com/2011/11/ec2-schedule-instance">his blog</a>, which
I&rsquo;ve modified below. Note the execution of our <a href="">familiar</a>
&ldquo;update.py&rdquo; script highlighted on line 4, and the apoptosis command on
line 46:</p>

<p>&ldquo;`bash #!/bin/bash -x exec &gt; &gt;(tee /var/log/user-data.log|logger -t
user-data -s 2&gt;/dev/console) 2&gt;&amp;1</p>

<p>/usr/bin/python /home/ubuntu/update.py # Run the script</p>

<p>EMAIL=spencer.g.boucher@gmail.com</p>

<h1 id="upgrade-and-install-postfix-so-we-can-send-a-sample-email-export">Upgrade and install Postfix so we can send a sample email export</h1>

<p>DEBIAN_FRONTEND=noninteractive apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp;
apt-get install -y postfix</p>

<h1 id="get-some-information-about-the-running-instance-instance_id-wget">Get some information about the running instance instance_id=$(wget</h1>

<p>-qO- instance-data/latest/meta-data/instance-id) public_ip=$(wget -qO-
instance-data/latest/meta-data/public-ipv4) zone=$(wget -qO-
instance-data/latest/meta-data/placement/availability-zone)
region=$(expr match $zone &rsquo;(.*).&rsquo;)  uptime=$(uptime)</p>

<h1 id="send-status-email-usr-sbin-sendmail-oi-t-f-email-lt-lt-eom-from">Send status email /usr/sbin/sendmail -oi -t -f $EMAIL &lt;&lt;EOM From:</h1>

<p>$EMAIL To: $EMAIL Subject: Results of EC2 scheduled script</p>

<p>This email message was generated on the following EC2 instance:</p>

<p>instance id: $instance<em>id region: $region public ip: $public</em>ip
  uptime: $uptime</p>

<p>If the instance is still running, you can monitor the output of this
job using a command like:</p>

<p>ssh ubuntu@$public_ip tail -1000f /var/log/user-data.log</p>

<p>ec2-describe-instances &ndash;region $region $instance_id</p>

<p>EOM</p>

<h1 id="give-the-script-and-email-some-time-to-do-their-thing-sleep-600-10">Give the script and email some time to do their thing sleep 600 # 10</h1>

<p>minutes</p>

<h1 id="this-will-stop-the-ebs-boot-instance-stopping-the-hourly-charges">This will stop the EBS boot instance, stopping the hourly charges.</h1>

<h1 id="have-auto-scaling-terminate-it-stopping-the-storage-charges">Have Auto Scaling terminate it, stopping the storage charges.</h1>

<h1 id="shutdown-h-now">shutdown -h now</h1>

<p>exit 0 &rdquo;`</p>

<p>Note that the user data script that we pass to the launch
configuration executes with <em>root</em> permissions, not as the user
&ldquo;ubuntu&rdquo; that you would typically log in as via <code>ssh</code>. Its probably
best to be as explicit as possible when specifying path names in the
cloud, the tilde operator might turn around and bite you.</p>

<p>Now we need to create <strong>launch configuration</strong> that will basically do
all the button-pushing that we would normally be doing at the AWS
console GUI.</p>

<p>Here we specify:</p>

<ul>
<li>  &ldquo;Micro&rdquo; as our instance type.</li>
<li>  Our shell script &ldquo;update.sh&rdquo; from step 2 as the
&ldquo;user-data-file&rdquo;. User data files are passed into the instance and
executed immediately when supplied in the launch
configuration. They must be less than 16kb as I suppose they are
stored on some ancillary server somewhere.</li>
<li>  The AMI image that we cloned in step 1 from the instance that
included our Python modules.</li>
<li>  The name of the launch config; let&rsquo;s call it
&ldquo;map-update-launch-config&rdquo;.</li>
</ul>

<p><code>bash as-create-launch-config --instance-type t1.micro
--user-data-file ~/Desktop/update.sh --image-id ami-fcdfb9cc
--launch-config &quot;map-update-launch-config&quot; as-describe-launch-configs
--headers</code></p>

<p>Note that the second line provides a list of all the launch
configurations that have been created.</p>

<p>We must also create an <strong>auto scaling group</strong>. These are typically
used as a sort of container to which we can add/remove instances on a
schedule or in response to heavy traffic, but we can also use it to
schedule a single instance to flick on and off. We need to tell it:</p>

<ul>
<li>  A name to assign the scaling group (&ldquo;map-update-scale-group&rdquo;).</li>
<li>  The name of the launch configuration we created in step 3
(&ldquo;map-update-launch-config&rdquo;).</li>
<li>  Which availability zone we want to use (basically irrelevant; we
set our environment variable <code>EC2_ZONE</code> to &ldquo;a&rdquo;
earlier). <code>ec2-describe-available-zones</code> provides a list of the
available zones</li>
<li>  A minimum and maximum number of instances in the group. We&rsquo;ll
initialize these to zero.</li>
</ul>

<p><code>bash as-create-auto-scaling-group --auto-scaling-group
&quot;map-update-scale-group&quot; --launch-configuration
&quot;map-update-launch-config&quot; --availability-zones &quot;$EC2_ZONE&quot; --min-size
0 --max-size 0 as-suspend-processes &quot;map-update-scale-group&quot;
--processes ReplaceUnhealthy as-describe-auto-scaling-groups --headers
</code></p>

<p>In the second line, we are using <code>as-suspend-processes</code> to prevent the
instance&rsquo;s default behavior which is to attempt to restart after it is
shut down. The third line provides a list of all the auto scaling
groups that have been created.</p>

<p>Last but not least, we are ready to assign a schedule to our auto
scaling group. Here we create two: one to start the instance and one
to terminate the instance. Astute readers will recall that &ldquo;update.sh&rdquo;
already <em>stops</em> the instance so that we aren&rsquo;t paying to have it
running, but we also need to completely <em>terminate</em> the instance so
that we aren&rsquo;t paying to store information about it. Each schedule
requires:</p>

<ul>
<li>  A name (<code>&quot;map-update-start&quot;</code> &amp; <code>&quot;map-update-stop&quot;</code>).</li>
<li>  The name of the auto scaling group we created in step 4
(&ldquo;map-update-scale-group&rdquo;).</li>
<li>  How we want to scale. By setting both <code>min-size</code> and <code>max-size</code> to
1, we are effectively turning on one instance. We later
effectively turn that instance back off by setting both to 0.</li>
<li>  A &ldquo;recurrence,&rdquo; ie when to occur. This flag uses the same syntax
that <code>cron</code> does. Here we set the instance to launch at midnight
UTC (<code>0 0 * * *</code>), and terminate 15 minutes later (<code>15 0 * *
*</code>). Recall that our script already stops the instance 10 minutes
after execution, so 15 minutes is playing it safe.</li>
</ul>

<p><code>bash as-put-scheduled-update-group-action --name &quot;map-update-start&quot;
--auto-scaling-group &quot;map-update-scale-group&quot; --min-size 1 --max-size
1 --recurrence &quot;0 0 * * *&quot; as-put-scheduled-update-group-action --name
&quot;map-update-stop&quot; --auto-scaling-group &quot;map-update-scale-group&quot;
--min-size 0 --max-size 0 --recurrence &quot;15 0 * * *&quot;
as-describe-scheduled-actions --headers</code></p>

<p>As before, the third line provides a list of the actions that have
been scheduled.</p>

<p>And thats it! We are now only paying for 10 or 15 minutes of cloud per
day, as opposed to 1,440 of them. To review the timeline we have
created in this example: our auto scaling group boots up an instance
up at midnight UTC that immediately executes &ldquo;update.sh&rdquo;. This
automatically executes &ldquo;update.py&rdquo; and shoots us a diagnostic
email. It then waits 10 minutes to make sure everything has time to
run, before stopping the instance. 5 minutes after <em>that</em> the auto
scaling group then completely terminates the instance.</p>

<p>Other great resources:</p>

<ul>
<li>  [Official Amazon documentation for scheduling auto scaling groups][]</li>
<li>  <a href="http://alestic.com/2011/11/ec2-schedule-instance">Running EC2 Instances on a Recurring Schedule with Auto Scaling</a></li>
<li>  <a href="http://www.robertsindall.co.uk/blog/how-to-use-amazons-auto-scaling-groups">Summary of API commands</a></li>
<li>  <a href="http://www.cardinalpath.com/autoscaling-your-website-with-amazon-web-services-part-2">Auto Scaling Your Website with Amazon Web Services</a></li>
</ul>

</article>




  <div class="py2 post-footer">
  <img src="/images/avatar.jpg" alt="Spencer Boucher" class="avatar" />
  <p>
    Spencer is a data scientist living in San Francisco, California.
  </p>
  <p>
    The source code for this post can be found here.
  </p>
</div>




  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname  = 'justmytwospence';
    var disqus_identifier = '/ec2-apis';
    var disqus_title      = 'Scheduling tasks in the cloud with EC2 APIs';

    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>






      </div>
    </div>
  </div>

  <footer class="center">
  <div class="measure">
    <small>
      Built with jekyll, github-pages, and <a href="https://github.com/johnotander/pixyll">Pixyll</a>.
    </small>
  </div>
</footer>

</body>
</html>
